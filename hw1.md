### SET 1

## Задача A1. Анализ корректности SELECTION SORT

# Task 1.
P1 = {A[j] >= A[minId]}  
Пояснение: на каждой итерации внутреннго цикла, если элемент на позиции j меньше элемента на позиции 
minId, то выполняется присваиваие minId = j, то есть условие P1 становится верным.  

# Task 2.
P2 = {A[i] <= A[i + 1], A[i] <= A[i + 2], ... , A[i] <= A[n - 1]}  
Пояснение: на каждой итерации внешний цикл ставит на i-е место минимальный из элементов среди стоящих на  
i, i + 1, ... , n - 1 местах. 

# Task 3.

Инвариант P1.

INIT: j не существует, считаем что все верно  
MNT: От противного: Если A[j] < A[minId], то выполняется присваиваение minId = j, и тогда A[j] = A[minId]  
TRM: j не существует, считаем что все верно  

Инвариант P2.

INIT: i не существует, считаем что все верно  
MNT: От противного: Если A[i] > A[i + k] для какого-то k, то на (k - 1)-й итерации 
внутреннего цикла j = i + k, то есть A[i] > A[j]. Так как i = minId, то A[minId] > A[j] - противоречие, Ч.Т.Д.  
TRM: i не существует, считаем что все верно  

## Задача A5. Поиск значения в отсортированной матрице



```
std::pair<int, int> findElem(const std::vector<std::vector<int>>& A, int n, int key) {
  int row = 0; // c1
  int col = 0; // c1

  while (row >= 0 && col < n) { // 2 * c3 * (2n - 1)
    int elem = A[row][col]; // c1

    if (elem == key) { // c3
      return {row, col}; // c4
    } else if (elem > key) { // c3
      ++row; // c2
    } else {
      ++col; // c2
    }
  }

  return {-1, -1}; // c4
}
```
